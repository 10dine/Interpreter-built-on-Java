import InterpreterDataTypes.*;
import Nodes.*;

import java.util.ArrayList;
import java.util.HashMap;

/**
 The Interpreter class is responsible for interpreting the AST generated by the parser
 and executing the program logic it represents.
 */
public class Interpreter {
	
	/**
	 The mainAST field stores the root node of the AST generated by the parser.
	 */
	ProgramNode mainAST;
	/**
	 Constructs an Interpreter object with the given root node of the AST generated by the parser.
	 @param programNode The root node of the AST generated by the parser.
	 @throws NodeErrorException If there is an error with the syntax tree nodes.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public Interpreter(ProgramNode programNode) throws NodeErrorException, InterpreterErrorException {
		this.mainAST = programNode;
		interpretFunction(mainAST.getFunction("start"));
	}
	/**
	 
	 Interprets a function node in the AST.
	 @param function The function node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretFunction(FunctionNode function) throws InterpreterErrorException {
		HashMap<String, InterpreterDataType> local = new HashMap<>();
		for(VariableNode param: function.getParameterList()){
			local.put(param.getName(), expression(local, param));
		}
		boolean cState;
		for(VariableNode variable: function.getVariableList()){
			cState = variable.iscSate();
			switch(variable.getType()){
				case integar -> {
					if(variable.getValue() != null){
						InterpreterDataType variableNodeData = expression(local, variable.getValue());
						variableNodeData.setcState(cState);
						if(variableNodeData instanceof IntegerDataType){
							local.put(variable.getName(), variableNodeData);
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						local.put(
								variable.getName(),
								new IntegerDataType(0, cState)
						);
					}
				}
				case real -> {
					if(variable.getValue() != null){
						InterpreterDataType variableNodeData = expression(local, variable.getValue());
						variableNodeData.setcState(cState);
						if(variableNodeData instanceof RealDataType){
							local.put(variable.getName(), variableNodeData);
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						local.put(
								variable.getName(),
								new RealDataType(0, cState)
						);
					}
				}
				case bool -> {
					if(variable.getValue() != null){
						InterpreterDataType variableNodeData = expression(local, variable.getValue());
						variableNodeData.setcState(cState);
						if(variableNodeData instanceof BooleanDataType){
							local.put(variable.getName(), variableNodeData);
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						local.put(
								variable.getName(),
								new BooleanDataType(){{
									setcState(variable.iscSate());
								}}
						);
					}
				}
				case character -> {
					if(variable.getValue() != null){
						InterpreterDataType variableNodeData = expression(local, variable.getValue());
						variableNodeData.setcState(cState);
						if(variableNodeData instanceof CharacterDataType){
							local.put(variable.getName(), variableNodeData);
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						local.put(
								variable.getName(),
								new CharacterDataType(cState)
						);
					}
				}
				case string -> {
					if(variable.getValue() != null){
						InterpreterDataType variableNodeData = expression(local, variable.getValue());
						variableNodeData.setcState(cState);
						if(variableNodeData instanceof StringDataType){
							local.put(variable.getName(), variableNodeData);
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						local.put(
								variable.getName(),
								new StringDataType(cState)
						);
					}
				}
				case arrayInt, arrayStr, arrayFlt -> local.put(
						variable.getName(),
						new ArrayDataType(new ArrayList<>() , variable.getType())
				);
				case abyss -> throw new InterpreterErrorException("SOMETHING REALLY BAD HAPPENED!");
			}
		}
		System.out.printf("[IDTs Before \"%s\" function's Block: %s]%n", function.getName(), local.toString());
		interpretBlock(local, function.getStatementList());
		System.out.printf("[IDTs After \"%s\" function's Block: %s]%n", function.getName(), local.toString());
	}
	/**
	 Interprets a block of statements in the AST.
	 @param local The local variables of the block.
	 @param block The block of statements to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretBlock(HashMap<String, InterpreterDataType> local, ArrayList<StatementNode> block) throws InterpreterErrorException {
		for(Node statement : block){
			if(statement instanceof AssignmentNode assignmentNode){
				if(local.containsKey(assignmentNode.getTargetVariableName().getVariableName())){
					InterpreterDataType assignmentData = local.get(assignmentNode.getTargetVariableName().getVariableName());
					if(!assignmentData.iscState()) {
						local.put(assignmentNode.getTargetVariableName().getVariableName(), expression(local, assignmentNode.getValue()));
					} else {
						throw new InterpreterErrorException(String.format(
								"[Error in interpretBlock(): \"%s\" is Constant!]",
								assignmentNode.getTargetVariableName().getVariableName()
						));
					}
				} else {
					throw new InterpreterErrorException(String.format(
							"[Error in interpretBlock(): %s does not exist in local!]",
							assignmentNode.getTargetVariableName()
					));
				}
			} else if (statement instanceof IfNode){
				interpretIfNode(local, (IfNode) statement);
			} else if (statement instanceof ForNode){
				interpretForNode(local, (ForNode) statement);
			} else if (statement instanceof RepeatNode){
				interpretRepeatNode(local, (RepeatNode) statement);
			} else if (statement instanceof WhileNode) {
				interpretWhileNode(local, (WhileNode) statement);
			}
		}
	}
	/**
	 Interprets an if-else statement node in the AST.
	 @param local The local variables of the block.
	 @param ifNode The if-else statement node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretIfNode(HashMap<String, InterpreterDataType> local, IfNode ifNode) throws InterpreterErrorException {
		IfNode next = (IfNode) ifNode.getNextIf();
		if(boolCompare(local, (BooleanCompareNode)ifNode.getCondition())){
			interpretBlock(local, ifNode.getStatementList());
		} else if (next != null) {
			interpretIfNode(local, next);
		}
	}
	/**
	 
	 Interprets a for loop node in the AST.
	 @param local The local variables of the block.
	 @param forNode The for loop node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretForNode(HashMap<String, InterpreterDataType> local, ForNode forNode) throws InterpreterErrorException {
		
		InterpreterDataType initial = expression(local, forNode.getFrom());
		if(!(initial instanceof IntegerDataType)){
			throw new InterpreterErrorException(String.format
					("[For Node cannot be processed: %s]", forNode)
			);
		}
		int initialInt = ((IntegerDataType) initial).getData();
		
		InterpreterDataType End = expression(local, forNode.getTo());
		if(!(End instanceof IntegerDataType)){
			throw new InterpreterErrorException(String.format
					("[For Node cannot be processed: %s]", forNode)
			);
		}
		int endInt = ((IntegerDataType) End).getData()+1;
		
		if(local.get((forNode.getVariable().getVariableName())) != null){
			throw new InterpreterErrorException("[Error in interpretForNode: Variable already in use!]");
		}
		
		for(int i = initialInt; i < endInt; i++){
			local.put((forNode.getVariable().getVariableName()), new IntegerDataType(initialInt));
			interpretBlock(local, forNode.getStatementList());
		}
		
		local.remove((forNode.getVariable().getVariableName()));
	}
	/**
	 Interprets a repeat-until loop node in the AST.
	 @param local The local variables of the block.
	 @param repeatNode The repeat-until loop node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretRepeatNode(HashMap<String, InterpreterDataType> local, RepeatNode repeatNode) throws InterpreterErrorException {
		do{
			interpretBlock(local, repeatNode.getStatementList());
		} while (!(boolCompare(local, repeatNode.getCondition())));
	}
	/**
	 Interprets a while loop node in the AST.
	 @param local The local variables of the block.
	 @param whileNode The while loop node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretWhileNode(HashMap<String, InterpreterDataType> local, WhileNode whileNode) throws InterpreterErrorException {
		while (boolCompare(local, whileNode.getCondition())){
			interpretBlock(local, whileNode.getStatementList());
		}
	}
	/**
	 Compares two boolean values.
	 @param local The local variables of the block.
	 @param booleanCompareNode The boolean comparison node to interpret.
	 @return true if the comparison is true, false otherwise.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public boolean boolCompare(HashMap<String, InterpreterDataType> local,BooleanCompareNode booleanCompareNode) throws InterpreterErrorException {
		InterpreterDataType left = expression(local, booleanCompareNode.getLeft());
		BooleanCompareNode.boolType comparator = booleanCompareNode.getComparator();
		InterpreterDataType right = expression(local, booleanCompareNode.getRight());
		
		try{
			switch(comparator){
				case COMPARATOR_EQUAL -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() == ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((IntegerDataType) left).getData() == ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() == ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() == ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((RealDataType) left).getData() == ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((RealDataType) left).getData() == ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() == ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((CharacterDataType) left).getData() == ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() == ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_NOT_EQUAL -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() != ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((IntegerDataType) left).getData() != ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() != ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() != ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((RealDataType) left).getData() != ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((RealDataType) left).getData() != ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() != ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((CharacterDataType) left).getData() != ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() != ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_LESS -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return ((IntegerDataType) left).getData() < ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType) {
							return ((IntegerDataType) left).getData() < ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType) {
							return ((IntegerDataType) left).getData() < ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType) {
						if (right instanceof IntegerDataType) {
							return ((RealDataType) left).getData() < ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType) {
							return ((RealDataType) left).getData() < ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType) {
							return ((RealDataType) left).getData() < ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType) {
						if (right instanceof IntegerDataType) {
							return ((CharacterDataType) left).getData() < ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType) {
							return ((CharacterDataType) left).getData() < ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType) {
							return ((CharacterDataType) left).getData() < ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_LESS_OR_EQUALS -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() <= ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((IntegerDataType) left).getData() <= ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() <= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() <= ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((RealDataType) left).getData() <= ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((RealDataType) left).getData() <= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() <= ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((CharacterDataType) left).getData() <= ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() <= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_GREATER -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() > ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((IntegerDataType) left).getData() > ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() > ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() > ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((RealDataType) left).getData() > ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((RealDataType) left).getData() > ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() > ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((CharacterDataType) left).getData() > ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() > ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_GREATER_OR_EQUALS -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() >= ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((IntegerDataType) left).getData() >= ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() >= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() >= ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((RealDataType) left).getData() >= ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((RealDataType) left).getData() >= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() >= ((IntegerDataType) right).getData();
						} else if (left instanceof RealDataType){
							return ((CharacterDataType) left).getData() >= ((RealDataType) right).getData();
						} else if (left instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() >= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
			}
		} catch (Exception e) {
			throw new InterpreterErrorException(
					String.format(
							"[Error in boolCompare: Incomparable Left Node(%s) and Right Node(%s)]"
							, left.toString(), right.toString()
					)
			);
		}
		return false;
	}
	/**
	Retrieves the value of a variable referenced in the AST.
	@param local The local variables of the block.
	@param variableReferenceNode The variable reference node to interpret.
	@return The value of the referenced
	@throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public InterpreterDataType getVariableFromReference(HashMap<String, InterpreterDataType> local, VariableReferenceNode variableReferenceNode) throws InterpreterErrorException {
		try{
			return local.get(variableReferenceNode.getVariableName());
		} catch (NullPointerException e){
			throw new InterpreterErrorException("[Error in expression: Variable not found in local!]");
		}
	}
	/**
	 * Evaluates an expression in the AST.
	 *
	 * @param local The local variables of the block.
	 * @param expressionNode The expression node to evaluate.
	 * @return The value of the evaluated expression.
	 * @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public InterpreterDataType expression(HashMap<String, InterpreterDataType> local, Node expressionNode) throws InterpreterErrorException {
		InterpreterDataType left = null;
		MathOpNode.operations operation = null;
		InterpreterDataType right = null;
		
		try {
			if (expressionNode instanceof VariableReferenceNode) {
				left = local.get(((VariableReferenceNode) expressionNode).getVariableName());
				if (left == null) {
					throw new InterpreterErrorException("[Error in expression: Variable not found in local!]");
				}
				return left;
			} else if (expressionNode instanceof MathOpNode) {
				try {
					left = expression(local, ((MathOpNode) expressionNode).getLeftSide());
					operation = ((MathOpNode) expressionNode).getOperator();
					right = expression(local, ((MathOpNode) expressionNode).getRightSide());
				} catch (Exception e) {
					throw e;
				}
			} else if (expressionNode instanceof IntegerNode) {
				left = new IntegerDataType(((IntegerNode) expressionNode).getElement());
			} else if (expressionNode instanceof RealNode) {
				left = new RealDataType(((RealNode) expressionNode).getElement());
			} else if (expressionNode instanceof StringNode) {
				left = new StringDataType(((StringNode) expressionNode).getElement());
			} else if (expressionNode instanceof CharNode) {
				left = new CharacterDataType(((CharNode) expressionNode).getElement());
			} else if (expressionNode instanceof BoolNode) {
				left = new BooleanDataType(((BoolNode) expressionNode).getState());
			} else {
				throw new InterpreterErrorException(String.format("[Error in expression: Invalid Node(%s)]", expressionNode));
			}
		}  catch (Exception e){
			throw new InterpreterErrorException(
				String.format(
						"[Error in expression: Invalid - (%s) Error Inside:[%s]]",
						expressionNode, e
				));
		}
		
		if(operation == null){
			return left;
		}
		try {
			switch (operation) {
				case ADD -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() + ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() + ((RealDataType) right).getData());
						} else if (right instanceof StringDataType) {
							return new StringDataType(((IntegerDataType) left).getData() + ((StringDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() + ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() + ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() + ((RealDataType) right).getData());
						} else if (right instanceof StringDataType) {
							return new StringDataType(((RealDataType) left).getData() + ((StringDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() + ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof StringDataType){
						if (right instanceof IntegerDataType) {
							return new StringDataType(((StringDataType) left).getData() + ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new StringDataType(((StringDataType) left).getData() + ((RealDataType) right).getData());
						} else if (right instanceof StringDataType) {
							return new StringDataType(((StringDataType) left).getData() + ((StringDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new StringDataType(((StringDataType) left).getData() + ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType) {
							return new IntegerDataType((((CharacterDataType) left).getData() + ((IntegerDataType) right).getData()));
						}else if (right instanceof CharacterDataType) {
							return new IntegerDataType((((CharacterDataType) left).getData() + ((CharacterDataType) right).getData()));
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
					
				}
				case SUBTRACT -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() - ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() - ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() - ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() - ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() - ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() - ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType) {
							return new IntegerDataType((char) (((CharacterDataType) left).getData() - ((IntegerDataType) right).getData()));
						}else if (right instanceof CharacterDataType) {
							return new IntegerDataType((char) (((CharacterDataType) left).getData() - ((CharacterDataType) right).getData()));
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case MULTIPLICATION -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() * ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() * ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() * ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() * ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() * ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() * ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case DIVISION -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() / ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() / ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() / ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() / ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() / ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() / ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case MOD -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() % ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() % ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() % ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() % ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() % ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() % ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
			}
		} catch (Exception e){
			throw new InterpreterErrorException(
					String.format(
							"[Error in expression: Invalid Operation - (%s %s %s) Error Inside:[%s]]",
							left, operation, right, e
					));
		}
		return left;
	}
	
}