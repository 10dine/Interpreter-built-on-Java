import InterpreterDataTypes.*;
import Nodes.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;
import java.util.stream.Collectors;

/**
 The Interpreter class is responsible for interpreting the AST generated by the parser
 and executing the program logic it represents.
 */
public class Interpreter {
	
	/**
	 The mainAST field stores the root node of the AST generated by the parser.
	 */
	ProgramNode mainAST;
	Scanner mainLog;
	/**
	 Constructs an Interpreter object with the given root node of the AST generated by the parser.
	 @param programNode The root node of the AST generated by the parser.
	 @throws NodeErrorException If there is an error with the syntax tree nodes.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public Interpreter(ProgramNode programNode) throws Exception {
		this.mainAST = programNode;
		mainLog = new Scanner(System.in);
		interpretFunction(mainAST.getFunction("start"), null);
		//mainLog.close();
	}
	/**
	 
	 Interprets a function node in the AST.
	 @param function The function node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretFunction(FunctionNode function, HashMap<String, InterpreterDataType> parameter) throws Exception {
		try {
			HashMap<String, InterpreterDataType> local;
			if (parameter != null) {
				local = parameter;
			} else {
				local = new HashMap<>();
			}
			
			boolean cState;
			for (VariableNode variable : function.getVariableList()) {
				cState = variable.iscSate();
				switch (variable.getType()) {
					case integar -> {
						if (variable.getValue() != null) {
							InterpreterDataType variableNodeData = expression(local, variable.getValue());
							variableNodeData.setcState(cState);
							if (variableNodeData instanceof IntegerDataType) {
								local.put(variable.getName(), variableNodeData);
							} else {
								throw new InterpreterErrorException("");
							}
						} else {
							local.put(
									variable.getName(),
									new IntegerDataType(0, cState)
							);
						}
					}
					case real -> {
						if (variable.getValue() != null) {
							InterpreterDataType variableNodeData = expression(local, variable.getValue());
							variableNodeData.setcState(cState);
							if (variableNodeData instanceof RealDataType) {
								local.put(variable.getName(), variableNodeData);
							} else {
								throw new InterpreterErrorException("");
							}
						} else {
							local.put(
									variable.getName(),
									new RealDataType(0, cState)
							);
						}
					}
					case bool -> {
						if (variable.getValue() != null) {
							InterpreterDataType variableNodeData = expression(local, variable.getValue());
							variableNodeData.setcState(cState);
							if (variableNodeData instanceof BooleanDataType) {
								local.put(variable.getName(), variableNodeData);
							} else {
								throw new InterpreterErrorException("");
							}
						} else {
							local.put(
									variable.getName(),
									new BooleanDataType() {{
										setcState(variable.iscSate());
									}}
							);
						}
					}
					case character -> {
						if (variable.getValue() != null) {
							InterpreterDataType variableNodeData = expression(local, variable.getValue());
							variableNodeData.setcState(cState);
							if (variableNodeData instanceof CharacterDataType) {
								local.put(variable.getName(), variableNodeData);
							} else {
								throw new InterpreterErrorException("");
							}
						} else {
							local.put(
									variable.getName(),
									new CharacterDataType(cState)
							);
						}
					}
					case string -> {
						if (variable.getValue() != null) {
							InterpreterDataType variableNodeData = expression(local, variable.getValue());
							variableNodeData.setcState(cState);
							if (variableNodeData instanceof StringDataType) {
								local.put(variable.getName(), variableNodeData);
							} else {
								throw new InterpreterErrorException("");
							}
						} else {
							local.put(
									variable.getName(),
									new StringDataType(cState)
							);
						}
					}
					case arrayInt, arrayStr, arrayFlt -> local.put(
							variable.getName(),
							new ArrayDataType(new ArrayList<InterpreterDataType>(), variable.getType())
					);
					case abyss -> throw new InterpreterErrorException("SOMETHING REALLY BAD HAPPENED!");
				}
			}
			System.out.printf("[IDTs Before \"%s\" function's Block: %s]%n", function.getName(), local.toString());
			interpretBlock(local, function.getStatementList());
			System.out.printf("\n[IDTs After \"%s\" function's Block: %s]%n", function.getName(), local.toString());
		} catch (Exception e){
			throw new InterpreterErrorException(String.format("[Error in interpretFunction (%s) \n\t-> (%s)]", function.getName(),e));
		}
	}
	/**
	 Interprets a block of statements in the AST.
	 @param local The local variables of the block.
	 @param block The block of statements to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretBlock(HashMap<String, InterpreterDataType> local, ArrayList<StatementNode> block) throws Exception {
		
		for(Node statement : block){
			try {
				if (statement instanceof AssignmentNode assignmentNode) {
					if (local.containsKey(assignmentNode.getTargetVariableName().getVariableName())) {
						InterpreterDataType assignmentData = local.get(assignmentNode.getTargetVariableName().getVariableName());
						if (!assignmentData.iscState()) {
							assignmentData.FromString(expression(local, assignmentNode.getValue()).toString());
							local.put(assignmentNode.getTargetVariableName().getVariableName(), assignmentData);
						} else {
							throw new InterpreterErrorException(String.format(
									"[Error in interpretBlock(): \"%s\" is Constant!]",
									assignmentNode.getTargetVariableName().getVariableName()
							));
						}
					} else {
						throw new InterpreterErrorException(String.format(
								"[Error in interpretBlock(): %s does not exist in local!]",
								assignmentNode.getTargetVariableName()
						));
					}
				} else if (statement instanceof IfNode) {
					interpretIfNode(local, (IfNode) statement);
				} else if (statement instanceof ForNode) {
					interpretForNode(local, (ForNode) statement);
				} else if (statement instanceof RepeatNode) {
					interpretRepeatNode(local, (RepeatNode) statement);
				} else if (statement instanceof WhileNode) {
					interpretWhileNode(local, (WhileNode) statement);
				} else if (statement instanceof FunctionCallNode) {
					interpretFunctionCall(local, (FunctionCallNode) statement);
				}
			} catch (Exception e){
				throw new InterpreterErrorException(String.format("[Error in interpretBlock for statement: \n(%s)\n\t-> (%s)]", statement,e));
			}
		}
	}
	/**
	 Interprets an if-else statement node in the AST.
	 @param local The local variables of the block.
	 @param ifNode The if-else statement node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretIfNode(HashMap<String, InterpreterDataType> local, IfNode ifNode) throws Exception {
		IfNode next = (IfNode) ifNode.getNextIf();
		if (ifNode.getCondition() == null){
			interpretBlock(local, ifNode.getStatementList());
		} else if (boolCompare(local, (BooleanCompareNode)ifNode.getCondition())){
			interpretBlock(local, ifNode.getStatementList());
		} else if (next != null) {
			interpretIfNode(local, next);
		}
	}
	/**
	 
	 Interprets a for loop node in the AST.
	 @param local The local variables of the block.
	 @param forNode The for loop node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretForNode(HashMap<String, InterpreterDataType> local, ForNode forNode) throws Exception {
		
		InterpreterDataType initial = expression(local, forNode.getFrom());
		if(!(initial instanceof IntegerDataType)){
			throw new InterpreterErrorException(String.format
					("[For Node cannot be processed: %s]", forNode)
			);
		}
		int initialInt = ((IntegerDataType) initial).getData();
		
		InterpreterDataType End = expression(local, forNode.getTo());
		if(!(End instanceof IntegerDataType)){
			throw new InterpreterErrorException(String.format
					("[For Node cannot be processed: %s]", forNode)
			);
		}
		int endInt = ((IntegerDataType) End).getData()+1;
		
		if(local.get((forNode.getVariable().getVariableName())) != null){
			throw new InterpreterErrorException("[Error in interpretForNode: Variable already in use!]");
		}
		
		
		for(int i = initialInt; i <= endInt; i++){
			local.put((forNode.getVariable().getVariableName()), new IntegerDataType(i));
			interpretBlock(local, forNode.getStatementList());
		}
		
		local.remove((forNode.getVariable().getVariableName()));
	}
	/**
	 Interprets a repeat-until loop node in the AST.
	 @param local The local variables of the block.
	 @param repeatNode The repeat-until loop node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretRepeatNode(HashMap<String, InterpreterDataType> local, RepeatNode repeatNode) throws Exception {
		do{
			interpretBlock(local, repeatNode.getStatementList());
		} while (!(boolCompare(local, repeatNode.getCondition())));
	}
	/**
	 Interprets a while loop node in the AST.
	 @param local The local variables of the block.
	 @param whileNode The while loop node to interpret.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public void interpretWhileNode(HashMap<String, InterpreterDataType> local, WhileNode whileNode) throws Exception {
		while (boolCompare(local, whileNode.getCondition())){
			interpretBlock(local, whileNode.getStatementList());
		}
	}
	
	/**
	 *
	 * @param local
	 * @param functionCallNode
	 */
	public void interpretFunctionCall(HashMap<String, InterpreterDataType> local, FunctionCallNode functionCallNode) throws Exception {
		FunctionNode function = null;
		try {
			function = mainAST.getFunction(functionCallNode.getName());
		} catch (NodeErrorException n) {
			throw new InterpreterErrorException(String.format("[interpretFunctionCall failed ->[%s]]", n));
		}
		
		try {
			if (!function.isVariadic()) {
				if (function.getParameterList().size() != functionCallNode.getParametertList().size()) {
					throw new InterpreterErrorException(String.format("[Error in interpretFunctionCall (parameters inputted are incorrect):{" +
									" Expected (%d) parameters, types (%s)} - {Actual (%d) parameters}]",
							function.getParameterList().size(), function.getParameterList().stream().map(VariableNode::getType).collect(Collectors.toList()),
							functionCallNode.getParametertList().size()
					)
					);
				}
				ArrayList<VariableNode> param = function.getParameterList();
				ArrayList<ParameterNode> paramsCalled = functionCallNode.getParametertList();
				//NEW IDT FOR FUNCTION CALL
				HashMap<String, InterpreterDataType> functionLocal = new HashMap<>();
				ArrayList<InterpreterDataType> paramsIDT = new ArrayList<>();
				for (int i = 0; i < param.size(); i++) {
					paramsIDT.add(expression(local, paramsCalled.get(i).getVar()).clone());
				}
				for (int i = 0; i < param.size(); i++) {
					InterpreterDataType idt = paramsIDT.get(i);
					ArrayList<String> paramCalledTypes = new ArrayList<>();
					switch(idt.getClass().getName()){
						case "InterpreterDataTypes.IntegerDataType":
							if (param.get(i).getType() == VariableNode.type.integar){
								break;
							}
							
						case "InterpreterDataTypes.RealDataType":
							if (param.get(i).getType() == VariableNode.type.real) {
								break;
							}
							
						case "InterpreterDataTypes.BooleanDataType":
							if (param.get(i).getType() == VariableNode.type.bool) {
								break;
							}
							
						case "InterpreterDataTypes.StringDataType":
							if (param.get(i).getType() == VariableNode.type.string) {
								break;
							}
							
						case "InterpreterDataTypes.CharacterDataType":
							if (param.get(i).getType() == VariableNode.type.character) {
								break;
							}
							
						default:

							throw new Exception(String.format("\n\t[Error in interpretFunctionCall (parameters inputted are incorrect):\n\t\t{" +
											"Expected (%d) parameters, types (%s)} \n\t\t{Actual (%d) (%s) parameters}]",
									function.getParameterList().size(),
									function.getParameterList().stream()
											.map(VariableNode::getType)
											.collect(Collectors.toList()),
									functionCallNode.getParametertList().size(),
									paramsIDT.stream()
											.map(InterpreterDataType::getClass)
											.map(Class::getName)
											.map(name -> name.substring(name.lastIndexOf('.') + 1))
											.collect(Collectors.toList())
									
							));
					}
					idt.setcState(!paramsCalled.get(i).isVar());
					functionLocal.put(param.get(i).getName(), idt);
				}
				interpretFunction(function, functionLocal);
				for (int i = 0; i < paramsCalled.size(); i++) {
					if (paramsCalled.get(i).isVar()) {
						String functionParameterName = param.get(i).getName();
						String varParameterName = paramsCalled.get(i).getVariable().getVariableName();
						local.put(varParameterName, functionLocal.get(functionParameterName));
					}
				}
			} else {
				ArrayList<ParameterNode> paramsCalled = functionCallNode.getParametertList();
				ArrayList<InterpreterDataType> variadicIDTS = new ArrayList<>();
				for (ParameterNode p : paramsCalled) {
					variadicIDTS.add(expression(local, p.getVar()));
				}
				if (function instanceof BuiltInWrite) {
					((BuiltInWrite) function).execute(variadicIDTS);
				} else if (function instanceof BuiltInRead) {
					((BuiltInRead) function).execute(variadicIDTS, mainLog);
					for (int i = 0; i < function.getParameterList().size(); i++) {
						String pName;
						if ((pName = paramsCalled.get(i).getVariable().getVariableName()) != null) {
							local.put(pName, variadicIDTS.get(i));
						}
					}
				}
			}
		} catch (Exception e){
			throw new InterpreterErrorException(String.format("[\tError in interpretFunctionCall (%s) \n\t-> (%s)]", function.getName(),e));
		}
	}
	/**
	 Compares two boolean values.
	 Follows the structure of the boolCompareNode
	 
	 By logic you should be able to compare left node
	 @param local The local variables of the block.
	 @param booleanCompareNode The boolean comparison node to interpret.
	 @return true if the comparison is true, false otherwise.
	 @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public boolean boolCompare(HashMap<String, InterpreterDataType> local,BooleanCompareNode booleanCompareNode) throws InterpreterErrorException {
		InterpreterDataType left = expression(local, booleanCompareNode.getLeft());
		BooleanCompareNode.boolType comparator = booleanCompareNode.getComparator();
		InterpreterDataType right = expression(local, booleanCompareNode.getRight());
		
		try{
			switch(comparator){
				case COMPARATOR_EQUAL -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() == ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((IntegerDataType) left).getData() == ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() == ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() == ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((RealDataType) left).getData() == ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((RealDataType) left).getData() == ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() == ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((CharacterDataType) left).getData() == ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() == ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_NOT_EQUAL -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() != ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((IntegerDataType) left).getData() != ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() != ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() != ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((RealDataType) left).getData() != ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((RealDataType) left).getData() != ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() != ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((CharacterDataType) left).getData() != ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() != ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_LESS -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return ((IntegerDataType) left).getData() < ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType) {
							return ((IntegerDataType) left).getData() < ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType) {
							return ((IntegerDataType) left).getData() < ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType) {
						if (right instanceof IntegerDataType) {
							return ((RealDataType) left).getData() < ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType) {
							return ((RealDataType) left).getData() < ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType) {
							return ((RealDataType) left).getData() < ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType) {
						if (right instanceof IntegerDataType) {
							return ((CharacterDataType) left).getData() < ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType) {
							return ((CharacterDataType) left).getData() < ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType) {
							return ((CharacterDataType) left).getData() < ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_LESS_OR_EQUALS -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() <= ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((IntegerDataType) left).getData() <= ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() <= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() <= ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((RealDataType) left).getData() <= ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((RealDataType) left).getData() <= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() <= ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((CharacterDataType) left).getData() <= ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() <= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_GREATER -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() > ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((IntegerDataType) left).getData() > ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() > ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() > ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((RealDataType) left).getData() > ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((RealDataType) left).getData() > ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() > ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((CharacterDataType) left).getData() > ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() > ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case COMPARATOR_GREATER_OR_EQUALS -> {
					if (left instanceof IntegerDataType){
						if (right instanceof IntegerDataType){
							return ((IntegerDataType) left).getData() >= ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((IntegerDataType) left).getData() >= ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((IntegerDataType) left).getData() >= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType){
							return ((RealDataType) left).getData() >= ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((RealDataType) left).getData() >= ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((RealDataType) left).getData() >= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType){
							return ((CharacterDataType) left).getData() >= ((IntegerDataType) right).getData();
						} else if (right instanceof RealDataType){
							return ((CharacterDataType) left).getData() >= ((RealDataType) right).getData();
						} else if (right instanceof CharacterDataType){
							return ((CharacterDataType) left).getData() >= ((CharacterDataType) right).getData();
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
			}
		} catch (Exception e) {
			throw new InterpreterErrorException(
					String.format(
							"[Error in boolCompare: Incomparable Left Node(%s) and Right Node(%s)]"
							, left.toString(), right.toString()
					)
			);
		}
		return false;
	}
	/**
	Retrieves the value of a variable referenced in the AST.
	@param local The local variables of the block.
	@param variableReferenceNode The variable reference node to interpret.
	@return The value of the referenced
	@throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public InterpreterDataType getVariableFromReference(HashMap<String, InterpreterDataType> local, VariableReferenceNode variableReferenceNode) throws InterpreterErrorException {
		try{
			return local.get(variableReferenceNode.getVariableName());
		} catch (NullPointerException e){
			throw new InterpreterErrorException("[Error in expression: Variable not found in local!]");
		}
	}
	/**
	 * Evaluates an expression in the AST.
	 *
	 * @param local The local variables of the block.
	 * @param expressionNode The expression node to evaluate.
	 * @return The value of the evaluated expression.
	 * @throws InterpreterErrorException If there is an error with the interpreter.
	 */
	public InterpreterDataType expression(HashMap<String, InterpreterDataType> local, Node expressionNode) throws InterpreterErrorException {
		InterpreterDataType left = null;
		MathOpNode.operations operation = null;
		InterpreterDataType right = null;
		
		try {
			if (expressionNode instanceof VariableReferenceNode) {
				left = local.get(((VariableReferenceNode) expressionNode).getVariableName());
				if (left == null) {
					throw new InterpreterErrorException("[Error in expression: Variable not found in local!]");
				}
				return left;
			} else if (expressionNode instanceof MathOpNode) {
				try {
					left = expression(local, ((MathOpNode) expressionNode).getLeftSide());
					operation = ((MathOpNode) expressionNode).getOperator();
					right = expression(local, ((MathOpNode) expressionNode).getRightSide());
				} catch (Exception e) {
					throw e;
				}
			} else if (expressionNode instanceof IntegerNode) {
				left = new IntegerDataType(((IntegerNode) expressionNode).getElement());
			} else if (expressionNode instanceof RealNode) {
				left = new RealDataType(((RealNode) expressionNode).getElement());
			} else if (expressionNode instanceof StringNode) {
				left = new StringDataType(((StringNode) expressionNode).getElement());
			} else if (expressionNode instanceof CharNode) {
				left = new CharacterDataType(((CharNode) expressionNode).getElement());
			} else if (expressionNode instanceof BoolNode) {
				left = new BooleanDataType(((BoolNode) expressionNode).getState());
			} else {
				throw new InterpreterErrorException(String.format("[Error in expression: Invalid Node(%s)]", expressionNode));
			}
		}  catch (Exception e){
			throw new InterpreterErrorException(
				String.format(
						"[Error in expression: Invalid - (%s) Error Inside:[%s]]",
						expressionNode, e
				));
		}
		
		if(operation == null){
			return left;
		}
		try {
			switch (operation) {
				case ADD -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() + ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() + ((RealDataType) right).getData());
						} else if (right instanceof StringDataType) {
							return new StringDataType(((IntegerDataType) left).getData() + ((StringDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() + ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() + ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() + ((RealDataType) right).getData());
						} else if (right instanceof StringDataType) {
							return new StringDataType(((RealDataType) left).getData() + ((StringDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() + ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof StringDataType){
						if (right instanceof IntegerDataType) {
							return new StringDataType(((StringDataType) left).getData() + ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new StringDataType(((StringDataType) left).getData() + ((RealDataType) right).getData());
						} else if (right instanceof StringDataType) {
							return new StringDataType(((StringDataType) left).getData() + ((StringDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new StringDataType(((StringDataType) left).getData() + ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType) {
							return new IntegerDataType((((CharacterDataType) left).getData() + ((IntegerDataType) right).getData()));
						}else if (right instanceof CharacterDataType) {
							return new IntegerDataType((((CharacterDataType) left).getData() + ((CharacterDataType) right).getData()));
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
					
				}
				case SUBTRACT -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() - ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() - ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() - ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() - ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() - ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() - ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof CharacterDataType){
						if (right instanceof IntegerDataType) {
							return new IntegerDataType((char) (((CharacterDataType) left).getData() - ((IntegerDataType) right).getData()));
						}else if (right instanceof CharacterDataType) {
							return new IntegerDataType((char) (((CharacterDataType) left).getData() - ((CharacterDataType) right).getData()));
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case MULTIPLICATION -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() * ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() * ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() * ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() * ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() * ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() * ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case DIVISION -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() / ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() / ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() / ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() / ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() / ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() / ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
				case MOD -> {
					if (left instanceof IntegerDataType) {
						if (right instanceof IntegerDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() % ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((IntegerDataType) left).getData() % ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new IntegerDataType(((IntegerDataType) left).getData() % ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else if (left instanceof RealDataType){
						if (right instanceof IntegerDataType) {
							return new RealDataType(((RealDataType) left).getData() % ((IntegerDataType) right).getData());
						} else if (right instanceof RealDataType) {
							return new RealDataType(((RealDataType) left).getData() % ((RealDataType) right).getData());
						} else if (right instanceof CharacterDataType) {
							return new RealDataType(((RealDataType) left).getData() % ((CharacterDataType) right).getData());
						} else {
							throw new InterpreterErrorException("");
						}
					} else {
						throw new InterpreterErrorException("");
					}
				}
			}
		} catch (Exception e){
			throw new InterpreterErrorException(
					String.format(
							"[Error in expression: Invalid Operation (Type Mismatch (%s %s %s)) - (%s %s %s) -> Error Inside:[%s]]",
							left.getClass().getName().split("\\.")[1], operation, right.getClass().getName().split("\\.")[1],
							left, operation, right, e
					));
		}
		return left;
	}
	
}